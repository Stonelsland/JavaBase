# Java设计模式

设计模式是在大量的实践中总结和理论化之后优选的代码结构，编程风格，以及解决问题的思考方式。俗称【套路】

创建型模式（5种）：工厂方法模式，抽象工厂模式、单例模式、，建造者模式、原型模式

结构型模式（7种）：适配器模式，装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式

行为型模式（11种）：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式

### 单例模式（Singleton）

单例设计模式就是采取一定的方法保证在整个软件系统中，某个类只能存在一个对象实例，减少系统性能开销

java.lang.Runtime

①首先必须将类的构造器的访问权限设为private，只能调用该类的某个静态方法

②该类对象的变量也必须定义为静态的

实现：

```java
//饿汉式实现单例模式
class Singleton{
    //1.私有化类的构造器
    private Singleton(){

    }

    //2.内部创建类的对象且声明为静态
    private static  Singleton instance = new Singleton();

    //3.提供公共的静态方法返回类的对象
    public static Singleton getInstance(){
        return instance;
    }
}
//懒汉式实现单例模式
class Single{

    //1.私有化类的构造器
    private Single(){

    }

    //2.声明当前类对象,并不初始化
    private static Single intance = null;

    //3.声明public，static的返回当前类的方法
    public static Single getIntance(){
        if (intance ==null){
            intance = new Single();
        }
        return intance;
    }
}
```

饿汉式与懒汉式的区别：

饿汉式：提前创建对象 

优点：饿汉式是线程安全的   缺点：对象加载时间过长

懒汉式：用时创建，不用则不创建

优点：延迟对象的创建 缺点：目前的写法↑线程不安全

单例模式的应用：网站计数器、应用程序的日志应用、数据库连接池、读取配置文件的类、Application也是典型的单例应用、Windows中的任务管理器和回收站也是典型的单例模式

### 模板方法设计模式

抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展，改造，但总体上会保留抽象类的行为方式

解决的问题：

当功能内部一部分实现是确定的，一部分实现是不确定的，这是可以把不确定的部分暴露出去让子类去实现，即在开发中实现一个算法时，整体步骤很固定，通用，但某些部分易变，易变部分则可以抽象出来供不同的子类去实现，这样便是一种模板模式

### 代理模式

代理模式是Java中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制这个对象的访问

应用：

	>安全代理：屏蔽对真实角色的直接访问
	>
	>远程代理：通过代理类处理远程方法调用（RMI）
	>
	>延迟加载：先加载轻量级的代理对象，真正需要时再加载真实对象

分类：

	>静态代理(静态定义代理类)
	>
	>动态代理（动态生成代理类）-JDK自带的动态代理（需要反射等知识）

### 工厂模式

工厂模式实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的

设计模式和面向对象设计原则都是为了使得开发项目更加容易扩展和维护，解决的方式就是“分工”

##### 工厂模式的分类

> ##### 简单工厂模式：
>
> ​	用来生产同一等级结构中的任意产品（对于增加的新产品，需要修改已有代码）。
>
> 优点：调用者只需要知道要什么，从哪里拿，不需要知道如何创建。分工，多出了一个专门生产实现类对象的工厂类，将调用者与创建者分离
>
> 缺点：对于增加新产品，不修改代码的话是无法扩展的，违反了开闭原则（对扩展开放，对修改封闭）。
>
> ##### 工厂方法模式：
>
> ​	用来生产同一等级结构中的固定产品（支持增加任意产品）
>
> ​	工厂方法模式则是为了避免简单工厂模式不满足OCP，与简单工厂模式最大的不同在于简单工厂模式只有一个工厂类（对于一个项目或者一个独立模块而言），而工厂方法模式则有一组实现了相同接口的工厂类
>
> 这样在简单工厂模式里集中在工厂方法上的压力可以由工厂方法模式中不同的工厂子类来分担
>
> ##### 抽象工厂模式：
>
> ​	用来生产不同产品族的全部产品（对于增加新的产品，无能为力，只支持添加产品族）
>
> 抽象工厂模式与工厂方法模式的区别就在于需要创建对象的复杂程度上，抽象工厂模式是最为抽象和一般性的，即给客户端提供一个接口，可以创建多个产品族中的产品对象
>
> 抽象工厂模式需要满足的条件：①系统中有多个产品族，而系统一次只可能消费其中一族产品②同属于同一个产品族的产品及其使用

核心本质：实例化对象，用工厂方法代替new操作。

将选择实现类，创建对象统一管理和控制，从而将调用者与实现类解耦

