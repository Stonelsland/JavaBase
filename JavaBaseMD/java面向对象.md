# Java面向对象

### java面向对象学习的三条主线

1.java类的成员，属性，方法，构造器，代码块，内部类

2.面向对象的三大特征：继承，封装，多态

3.其他关键字 this super static final interface等

#### 面向过程与面向对象:

面向过程:强调的是功能行为,以函数为最小单位,考虑怎么做

面向对象:强调了具备功能的对象,以类/对象为最小单位,考虑谁来做

开发者从面向过程的执行者变成了面向对象的指挥者

##### 对象的内存解析

堆(Heap):存放对象实例,new的对象在堆中,地址存储在栈中

栈(Stack):用于存储局部变量,局部变量表存放了基本数据类型,对象引用,方法执行完自动释放

方法区(Method Area)用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等

##### 属性与局部变量的区别:

相同点:定义格式都为 数据类型 变量名 = 变量值;

都要先声明再使用,且都有其对应的作用域

区别:

1.在类中的声明位置不同,属性直接定义在{}中,局部变量声明在方法内,方法形参,代码块内,构造器形参,构造器内部的变量

2.属性可以用权限修饰符,局部变量不可以

3.属性根据其类型具有默认初始化值,局部变量必须显式赋值,形参在调用的时候赋值即可

4.属性加载到堆空间中,局部变量加载到栈空间中.(非static)

匿名对象:创建对象没有显式赋予变量名即为匿名对象,只能调用一次 常作为参数使用

方法重载:两同一不同:同一个类,相同方法名,参数列表不同,参数个数不同,参数类型不同

### 封装:

封装性的体现:

1 创建一个类的对象,通过对象.属性的方式进行赋值,赋值操作要受到数据类型和存储范围的制约,除此之外,没有其他制约条件,但是在实际奇怪狂中,往往需要给属性加入额外的限制条件,这个条件不能在声明中体现,只能通过方法进行限制条件的添加,同时避免用户再使用对象.属性的方式对属性进行赋值,则需要将类的属性私有化(private),同时提供公共的方法来获取(get)和设置(set)属性的值

2 方法私有化,内部运行,外部不可访问

3 单例模式(构造器私有化)

##### 权限修饰符

private 只可在类内部使用

(缺省) 同一个包内可以使用

protected 不同包的子类也可使用

public 同一个工程中可以使用

##### 构造器(构造方法--实则不是方法)

1.构造器的作用:

创建对象  初始化对象的信息

2.说明

如果没有显示定义构造器的话,则系统默认提供给一个空参构造器,一旦显式定义了类的构造器,系统便不再提供默认的空参构造器

定义构造器的格式 权限修饰符 类名(形参列表){}

一个类中的多个构造器,彼此构成重载

##### JavaBean :

JavaBean是一种java语言写成的可重用的组件,指符合如下标准的java类: 

1 类是公共的 

2 有一个无参的公共构造器

 3有属性及对应的getset方法 

#### this关键字:

##### this用来修饰属性,方法,构造器

this修饰属性和方法,理解为当前对象,在类的方法(构造器)中可以使用this.属性或this.方法,调用当前(正在创建的)对象的属性或方法,但通常情况话都选择省略,若方法的形参与类的属性同名时,this不可省略.

##### this调用构造器

在类的构造器中,可以显式的使用this(形参列表);的方式调用本类中的其他构造器

构造器中不能用此形式调用自己

如果一个类中有n个构造器,则最多有n-1个构造器使用this方法

规定this(形参列表);形式必须放在构造器的首行

构造器内部最多只能声明一个this(形参列表);调用其它构造器

##### MVC设计模式:

MVC是最常用的设计模式之一,将整个程序分为三个层次,视图模型层(View),控制器层(Controller)和数据模型层(Model),将程序输入输出,数据处理以及数据展示分离开来的设计模式,使程序结构变得灵活而清晰,同时也描述了程序各个对象间的通信方式,降低了程序的耦合性

### 继承

##### 继承性的优点:

减少了代码的冗余,便于功能的扩展,为多态也提供了前提

子类继承父类后获取父类中声明的所有结构,属性和方法,也可以再定义自身的属性和方法,实现功能的扩展

子类与父类不同集合与子集,子类往往比父类的功能更多

父类中声明为私有的属性或方法,仍然认为获取了父类中的私有结构,只因封装性,子类不可直接调用,需调用get,set方法

##### java中关于继承的规定:

一个类只能有一个父类,但可以被多个类继承

子类与父类是相对的概念,子类继承父类之后,就获取了父类及所有间接父类中声明的属性和方法

若没有显式的声明父类,则默认继承Object类,Java中所有的类都直接或间接继承Object类

##### 方法重写(Override)

在子类中可以根据需要对从父类中继承的方法进行改造,也称为方法的覆盖,在程序执行时,子类的方法将覆盖父类的方法

###### 重写的规则:

子类的重写方法必须和父类被重写的方法具有相同的方法名称及参数列表,返回值类型不能大于父类被重写方法的返回值类型,访问权限不能小于父类被重写方法的访问权限.

子类不能重写父类中声明为private的方法,子类的方法抛出的异常不能大于父类被重写方法的异常

注:子类与父类中同名同参数的方法必须同时声明为非static(即为重写),或者同时声明为static(非重写),因为static方法属于类,子类无法覆盖父类的方法

#### super关键字:

super理解为父类的,可以用来调用父类的属性,方法,构造器

##### super调用方法(属性):

在子类的方法或构造器中,通过使用super.方法(属性)显式调用父类的方法(属性),但是通常情况下选择省略.

当子类和父类中定义了同名方法(属性)时,子类想要调用父类中的方法(属性)时,则必须显式地使用super.方法(属性)的方式表明调用的是父类中的方法(属性).

##### super调用构造器:

我们可以在子类构造器中显式地使用super(形参列表)的形式调用父类中声明的指定的构造器,super(形参列表)的使用,必须声明在子类构造器的首行.

在类的构造器中this(形参列表)与super(形参列表)只能存在一个,不能同时出现.

若在子类构造器的首行没有显式地声明则默认调用父类的无参构造器.

在类的多个构造器中,至少有一个类的构造器中使用了super(形参列表)来调用父类中的构造器.

##### 子类对象的实例化过程

从结果看:子类继承父类之后,就获取了父类中声明的属性或方法,创建子类的对象,在堆空间中,就会加载所有父类中声明的属性

从过程看:通过子类构造器创建子类对象时,一定会直接或间接的调用父类的构造器,进而调用父类的父类构造器,直到调用java.lang.Object类中的空参构造器为止

虽然创建子类对象时调用了父类的构造器,但自始至终只创建一个对象,即new的子类对象

### 多态性

对象的多态性,父类的引用指向子类的对象 

##### 多态的使用:(虚拟方法调用)

子类中定义了与父类同名同参数的方法在多态的情况下,此时的父类方法为虚拟方法,父类根据赋给他的不同的子类对象,动态调用属于子类的方法,这样的方法调用在编译期是无法确定的

实现对象的多态性后,编译期只能调用父类中声明的方法,但是在 运行期实际执行的是子类重写父类的方法,即编译看左边,运行看右边

多态是运行时行为

##### 多态性的使用前提:

① 需要有类的继承关系   ② 存在方法的重写

对象的多态性只适用于方法 不适用于属性

##### instanceof关键字

实现多态性后,内存中实际上是加载了子类特有的属性和方法的,但由于变量声明为父类类型,导致编译时,只能调用父类的属性和方法,子类特有的属性和方法不能调用.

如何调用子类特有的属性和方法:使用强制类型转换(向下转型)

instanceof的使用: a instanceof A:判断对象a是否是类A的实例,若是则返回true不是则返回false

为了避免向下转型时出现ClassCastException异常,在转型前进行instanceof判断,返回true则向下转型,返回false则不进行.

若 a instanceof A返回true ,B是A的父类,则a instanceof B也返回true.

##### Object类的使用

Object类是所有java类的根父类

若在类的声明中未使用extends关键字指明父类，则默认继承java.lang.Object类

Object类中的功能(属性,方法)具有通用性

###### equals()方法

==(运算符):可以使用在基本数据类型和引用数据类型变量中,若果比较的是基本数据类型变量,则比较两个变量保存的数据是否相等(数据类型不一定相同),若比较的是引用数据类型,则比较的是地址值是否相同,即两个引用是否指向同一个对象实体

equals()[方法]:只能适用于引用数据类型

Object类中对equals()的定义:

```java
public boolean equals(Object obj){                        				 			return (this == obj);
```

}说明Object类中定义的equals()和==的作用是相同的

String,Date,File,包装类等都重写了Object类中的equals()方法,重写之后比较的不再是两个引用的地址值是否相同,而是比较两个对象的"实体内容"是否相同

通常情况下,自定义的类如果使用equals(),也是比较两个对象的"实体内容"是否相同

,则需要对Object类中的equals()方法进行重写 :(例Customer类)

```java
public boolean equals(Object obj){                   		                            if (this == obj){               												return true;}
	if(obj instanceof Customer){
		Customer cust = (Customer)obj;
		//if(this.age==cust.age&&this.name.equals(cust.name)){
		//	return true;
		//}else{
		//	return false;
		//}
		return this.age==cust.age&&this.name.equals(cust.name);
	}
	return false;
}
```

重写的原则:比较两个对象的实体内容是否相同

###### toString()方法:

当输出一个对象的引用时实际上是调用了当前对象的toString();

Object中定义的toString():

```java
    public String toString() {
        return this.getClass().getName() + "@" + 					  						Integer.toHexString(this.hashCode());
    }

```

String,Date,File,包装类等都重写了Object类中的toString()方法

### 包装类(封装类)

针对八种基本数据类型定义相应的引用类型,父类为Number有了类的特点就可以调用类中的方法,Java才是真正的面向对象

基本数据类型，包装类与String的相互转化

基本数据类型--->包装类:调用包装类的构造器例:int num = 10; Integer in = new Integer(num);

包装类-->基本数据类型:调用包装类的xxxValue();

Integer in = new Integer(10);		int i =  in.intValue();

自动装箱与自动拆箱

自动装箱: int num  =10; Integer in = num;    自动拆箱: int i = in;

基本数据类型,包装类--->String: 

①int i = 10; String str = i+""; ②float f = 12.3f; String str = String.valueOf(f);

String--->基本数据类型,包装类: 调用包装类的parsexxx();

 ①String str = "10"; int num = Integer.parseInt(str);

Interger内部定义了IntegerCache结构,IntegerCache中定义了Integer[],保存了从-128--127范围的整数,如果使用自动装箱的方式给Integer赋值的范围在-128--127的范围内时则可以直接使用数组中的元素而不用再去new .目的是提高效率



### 关键字的使用

#### static关键字

static:静态的,可以用来修饰属性,方法,代码块,内部类

##### 修饰属性:

属性可以按照是否被static修饰分为静态属性(静态变量,类变量)与非静态属性(实例变量)

实例变量:创建类的多个对象,每个对象都独立s的拥有一套非静态属性,当修改其中一个对象中的非静态属性时,不会导致其他对象中同样的属性值被修改

静态变量:创建类的多个对象,多个对象共享同一个静态变量,当通过某一个对象修改静态变量,会导致其他的对象调用时,为修改过的静态变量

静态变量随着类的加载而加载,通过"类.静态变量"的方式进行调用,早于对象的创建,由于类只加载一次,所以静态变量在内存中也只有一份,存在方法区的静态域中

##### 修饰方法:

随着类的加载而加载,可以通过"类.静态方法"的方式调用,静态方法中,只能调用静态方法或属性

在静态结构中,不能使用this和super关键字

关于静态属性与静态方法的使用,从生命周期的角度理解 

判定是否需要使用static: ①属性被多个对象所共享,不会随着对象的改变而改变 ②操作静态属性的方法和工具类中的方法习惯上声明为static

#### final关键字

final可以用来修饰类，方法和变量

修饰类则此类不能被其他类所继承，修饰方法则此方法不可被重写，修饰变量则此变量相当于一个常量，特别的，当final修饰形参时，表明此形参是一个常量，当调用此方法时，给常量形参赋一个实参，一旦赋值以后，就只能在方法体内使用此形参，但不能重新进行赋值。

static final用来修饰属性和全局常量

### 代码块（初始化块）

代码块的作用：用来初始化类或对象，只能用static修饰，分为静态代码块与非静态代码块

静态代码块：内部可以有输出语句，随着类的加载而执行，且只执行一次，若定义了多个静态代码块，则按声明的先后顺序执行

作用：初始化类的信息

非静态代码块：内部可以有输出语句，随着对象的创建而执行，每创建一次对象，就执行一次非静态代码块

作用：可以在创建对象是，对对象的属性进行初始化

静态代码块只可调用静态的属性和方法，不能调用非静态属性和方法，非静态代码块则都可以调用

### 抽象类与抽象方法

定义：将一个父类设计得非常抽象以至于没有具体的实例的类即抽象类

##### abstract关键字

abstract：抽象的

可以用来修饰类和方法，被修饰的类或方法即为抽象类或抽象方法

##### 抽象类：

> ①不能实例化
>
> ② 抽象类中一定有构造器，便于子类对象实例化时调用（涉及子类对象实例化的全过程）
>
> ③开发中都会提供抽象类的子类，让子类对象实例化，完成相关的操作

##### 抽象方法：

> ①抽象方法只有方法的声明，没有方法体 
>
> ②包含抽象方法的类一定是抽象类，抽象类中不一定有抽象方法 
>
> ③若子类重写了父类中所有的抽象方法后，此子类方可实例化 ，若子类没有重写父类中的所有方法，则此子类也为抽象类，需用abstract修饰

###### abstract使用注意：

> ①abstract不能用来修饰属性，构造器等
>
>  ②不能用来修饰私有方法、静态方法、final的方法、final的类

### 接口（interface）

接口解决了java中不可多继承的问题，继承为is-a的关系，接口则是has-a的关系

接口的本质是契约，标准，规范，定义好之后就要遵守

①接口使用interface来定义

②Java中，接口和类是并列的结构

③接口的定义：

​	Ⅰ**jdk7**及之前：只能定义全局常量和抽象方法

>全局常量：public static final修饰，但书写时可以省略，默认存在
>
>抽象方法：public abstract，同样默认存在，可以省略

​	Ⅱ **jdk8**：除了上述之外还可以定义静态方法，默认方法

	>静态方法：使用static关键字修饰，可以通过接口直接调用静态方法，且只能通过接口来调用
	>
	>默认方法：使用default关键字修饰，可以通过实现类来调用。
	
	>1. 若实现类重写了接口中的默认方法，调用时仍然调用重写以后的方法
	>
	>2. 若实现类继承的父类和实现的接口中声明了同名同参数方法，在实现类没有重写的情况下，默认调用父类中的同名同参数方法（类优先原则）
	>
	>3. 若实现类实现了多个接口，多个接口中定义了同名同参数的默认方法，在实现类没有重写方法的情况下，报错---接口冲突，若想实现则必须重写此方法
	>
	>4. 在实现类中调用父类，接口中被重写的方法：
	>
	>   父类：super.方法名();
	>
	>   接口：接口名.super.方法名();

④接口中不能定义构造器，意味着接口不可以实例化

⑤Java开发中，接口通过让类去实现（implements）的方式使用，如果实现类覆盖了接口中所有的抽象方法，则此实现类可以实例化，否则此类只能时一个抽象类

⑥Java类可以实现多个接口，弥补了Java继承的局限性

⑦接口与接口之间也可以继承，并且可以多继承

⑧接口的具体使用体现多态性

⑨接口实际上可以看做是一种规范

面试题：抽象类与接口的异同

### 内部类

Java中允许讲一个类B声明在另一个类A的内部,则B为A的内部类

分为成员内部类(静态,非静态)和局部内部类(方法,代码块,构造器内)

成员内部类: 

作为外部类的成员,可以调用外部类的结构,可以被static修饰,也可以被四种权限修饰

作为一个类,可以定义属性方法和构造器,可被final,abstract修饰

三个问题:

1.如何实例化成员内部类的对象

​	外部类A 静态内部类B 非静态内部类C

​	静态内部类实例化:  A.B b  = new A.B();

​	非静态内部类实例化: A a = new A(); A.C c = a.new C();

2.如何在成员内部类中区分调用外部类的结构

​	外部类A 内部类B 重名属性id

​	形参:id 内部类:this.id 外部类:A.this.id

3.开发中局部内部类的使用

